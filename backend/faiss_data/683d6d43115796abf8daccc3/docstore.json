[[["6acb3552-fa2c-4953-b86e-37a179e599b6",{"pageContent":"A simpler implementation and analysis of Chazelle’s Soft Heaps\nHaim Kaplan\n∗\nUri Zwick\n∗\nAbstract\nChazelle (JACM 47(6), 2000) devised an approximate\nmeldable  priority  queue  data  structure,  calledSoft\nHeaps, and used it to obtain the fastest known determin-\nistic comparison-based algorithm for computing mini-\nmum spanning trees, as well as some new algorithms\nfor selection and approximate sorting problems. Ifnel-\nements are inserted into a collection of soft heaps, then\nup toεnof the elements still contained in these heaps,\nfor a givenerror parameterε,maybecorrupted, i.e.,\nhave their keys artificially increased.  In exchange for\nallowing these corruptions, each soft heap operation is\nperformed inO(log\n1\nε\n) amortized time.\nChazelle’s soft heaps are derived from thebinomial\nheapsdata  structure  in  which  each  priority  queue  is\ncomposed of a collection ofbinomial trees. We describe\na simpler and more direct implementation of soft heaps","metadata":{"loc":{"lines":{"from":3,"to":27}}}}],["c5226c24-b1a9-4023-9539-3c0cc4a8bdeb",{"pageContent":"heapsdata  structure  in  which  each  priority  queue  is\ncomposed of a collection ofbinomial trees. We describe\na simpler and more direct implementation of soft heaps\nin which each priority queue is composed of a collection\nof standardbinarytrees.  Our implementation has the\nadvantage that noclean-upoperations similar to the\nones  used  in  Chazelle’s  implementation  are  required.\nWe also present a concise and unified potential-based\namortized analysis of the new implementation.\n1  Introduction\nChazelle [4, 2] devised an approximate meldable prior-\nity queue data structure, calledSoft Heaps, and used it\nto obtain the fastest known deterministic comparison-\nbased algorithm for computing minimum spanning trees\n(Chazelle [3, 2]), as well as some new algorithms for se-\nlection and approximate sorting problems. Ifnelements\nare inserted into a collection of soft heaps, then up to\nεnof the elements still contained in these heaps, for a\ngivenerror  parameterε,maybecorrupted, i.e., have","metadata":{"loc":{"lines":{"from":25,"to":43}}}}],["889e34be-8185-492e-9cdb-2c1800fb0b13",{"pageContent":"are inserted into a collection of soft heaps, then up to\nεnof the elements still contained in these heaps, for a\ngivenerror  parameterε,maybecorrupted, i.e., have\ntheir keys artificially increased.  (Note thatnhere is\nthe number of elements inserted into the heaps, not the\ncurrent number of elements in the heaps which may be\nconsiderably smaller.)  In exchange for allowing these\ncorruptions, each soft heap operation is performed in\nO(log\n1\nε\n) amortized time.\n∗\nSchool of Computer Science, Tel Aviv University, Tel Aviv\n69978, Israel.  E–mail:{haimk,zwick}@tau.ac.il.  Uri’s research\nwas supported by BSF grant no. 2006261.  Haim Kaplan is\npartially supported by BSF grant no. 2006204\nSoft  heaps  are  also  used  by  Pettie  and  Ra-\nmachandran [8, 9] to obtain an optimal deterministic\ncomparison-based algorithm for finding minimum span-\nning trees, with a yet unknown running time, and for\nobtaining a randomized linear time algorithm for the","metadata":{"loc":{"lines":{"from":41,"to":62}}}}],["f656c376-652c-4d45-8b15-659d414ebece",{"pageContent":"comparison-based algorithm for finding minimum span-\nning trees, with a yet unknown running time, and for\nobtaining a randomized linear time algorithm for the\nproblem that uses only a small number of random bits.\nChazelle’s soft heaps are derived from thebinomial\nheapsdata  structure  in  which  each  priority  queue  is\ncomposed of a collection ofbinomial trees. We describe\na simpler and more direct implementation of soft heaps\nin which each priority queue is composed of a collection\nof standardbinarytrees.  Our implementation has the\nadvantage that noclean-upoperations similar to the\nones  used  in  Chazelle’s  implementation  are  required.\nWe also present a concise and unified potential-based\namortized analysis of the new implementation.\n1.1  Soft heapsSoft heaps are approximate meld-\nable priority queue data structures that support the fol-\nlowing operations:\nmake-heap(e)  –  Generate  and  return  a  new\nsoft heap containing the single elemente\nwhose original key iskey[e].","metadata":{"loc":{"lines":{"from":60,"to":79}}}}],["384ae81c-52a2-4883-a557-f8862710868a",{"pageContent":"able priority queue data structures that support the fol-\nlowing operations:\nmake-heap(e)  –  Generate  and  return  a  new\nsoft heap containing the single elemente\nwhose original key iskey[e].\ninsert(P, e)  – Insert elemente, with original\nkeykey[e], into soft heapP.\ndelete(e)  –  Delete  elementefrom  the  soft\nheap currently containing it.   (It is as-\nsumed thateis currently contained in ex-\nactly one soft heap.)\nmeld(P, Q)  – Meld the two soft heapsPand\nQ, destroying them in the process, and\nreturn the melded heap.\nextract-min(P)  –  Return  an  element  with\nthe smallestcurrentkey in soft heapP\nand delete it fromP.\nIt  is  important  to  note  that  anextract-min(P)\noperation returns an elementewith the smallestcurrent\nkey contained inP.  The current key of an elemente\nmay  be\nlargerthen\nitsoriginalkeykey[e],\nwhich  is\nnever changed by the implementation. Elements whose\ncurrent key is larger than their original key are said to\nbecorrupted.  Current keys of elements are sometimes","metadata":{"loc":{"lines":{"from":75,"to":101}}}}],["7c910f57-f394-4b55-880a-bd9fbc056ffc",{"pageContent":"itsoriginalkeykey[e],\nwhich  is\nnever changed by the implementation. Elements whose\ncurrent key is larger than their original key are said to\nbecorrupted.  Current keys of elements are sometimes\n477Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":97,"to":104}}}}],["0200ee4f-50f6-4e0e-9dfa-ea75e638047a",{"pageContent":"raised  to  speed-up  the  implementation  of  soft  heap\noperations.The  user  has  no  control  as  to  which\nelements become corrupted.\nIf soft heaps were allowed to corrupt all elements\nthen their implementation would be trivial,  but they\nwould be useless.  A surprisingly useful data structure\nis obtained if we require that at mostεnof the elements\nstill contained in soft heaps are corrupted, wherenis\nthe total number of elements inserted so far into soft\nheaps, and 0<ε<1 is a prespecifiederror parameter.\nNote that an element is inserted into a soft heap by\neither amake-heapor aninsertoperation.  Also note\nthat corrupted elements that were removed from soft\nheaps byextract-minoperations are not counted.\nFollowing Chazelle [4], we describe an implementa-\ntion of soft heaps with error parameterεin which the\namortized cost ofmake-heapandinsertoperations is\nO(log\n1\nε\n) and the amortized cost of all other operations\nis 0.\n2  Implementation","metadata":{"loc":{"lines":{"from":106,"to":128}}}}],["2c49ca1e-9f9e-481a-b899-70edc20b1aed",{"pageContent":"tion of soft heaps with error parameterεin which the\namortized cost ofmake-heapandinsertoperations is\nO(log\n1\nε\n) and the amortized cost of all other operations\nis 0.\n2  Implementation\nIn this section we describe the implementation of all\nsoft heap operations, except thedeleteoperation which\nwill be added in Section 5.  (We note that some of the\napplications listed by Chazelle [4] do not usedelete\noperations.)\n2.1  The data structureEach soft heap priority\nqueue is composed of a collection of binary trees.  A\nnodexof a binary tree may have a left childleft[x]\nand  may  have  a  right  childright[x].   Ifxdoes  not\nhave a left child, thenleft[x]=⊥, where⊥represents\nnull.  Similarly, ifxdoes not have a right child, then\nright[x]=⊥.   Every  nodexin  a  binary  tree  has  an\nintegerrank,  denoted byrank[x],  associated with it.\nThe rank of a node never changes.  Ifxis a node of\nrankk,  then the ranks ofleft[x]andright[x],  if they\nexist, arek−1.  The rank of a tree is defined as the","metadata":{"loc":{"lines":{"from":121,"to":144}}}}],["134d918f-fab9-48dc-ade3-99097c9330aa",{"pageContent":"The rank of a node never changes.  Ifxis a node of\nrankk,  then the ranks ofleft[x]andright[x],  if they\nexist, arek−1.  The rank of a tree is defined as the\nrank of its root.\nEach nodex,hasatarget  sizesize[x] associated\nwith it.  Letr=\u0003log\n2\n1\nε\n\u0004+ 5, whereεis the desired\nerror rate.  The target sizesize[x] of a node of rankk\niss\nk\n, where\ns\nk\n=\n{\n1ifk≤r,\n\u0003\n3s\nk−1\n2\n\u0004otherwise.\n(The choice of 3/2 in the definition ofs\nk\nis arbitrary.\nAny constant strictly between 1 and 2 would do.) Thus\ns\n0\n=s\n1\n=...=s\nr\n= 1, whiles\nr+1\n=2,s\nr+2\n=3,\ns\nr+3\n=5,s\nr+4\n=8,s\nr+5\n= 12, etc.  It is easy to prove\nthat\n(\n3\n2\n)\nk−r\n≤s\nk\n≤2\n(\n3\n2\n)\nk−r\n−1fork≥r.\nEach  nodexhas  a  list  of  elementslist[x].   The\nnumber of elements inlist[x] is ‘roughly’size[x]. (This\nwill be made more precise below.)  A nodexalso has\nakeyckey[x] which is an upper bound on the keys of\nthe elements contained inlist[x].   Ifeis an element\ncontained  inlist[x],  andkey[e]<ckey[x],  theneis","metadata":{"loc":{"lines":{"from":142,"to":208}}}}],["5ce56098-91a7-46dc-abcf-9d4c49cb2cbb",{"pageContent":"akeyckey[x] which is an upper bound on the keys of\nthe elements contained inlist[x].   Ifeis an element\ncontained  inlist[x],  andkey[e]<ckey[x],  theneis\ncorrupted. The data structure behaves as if the key ofe\nis artificially raised tockey[x].  (In the terminology of\nthe previous section, ifeis an element oflist[x], then\nckey[x] is the current key ofe.)\nEach tree isheap orderedwith respect to theckey\nvalues,  i.e.,  ifxis  a  node  andleft[x]  exists,  then\nckey[x]≤ckey[left[x]]. Similarly, ifright[x] exists, then\nckey[x]≤ck\ney[right[x]].\nA\npriority queuePis composed of a sequence of\ntrees, at most one of each rank. The rankrank[P]ofP\nis defined to be the largest rank of a tree inP.The\ntrees composingPare arranged in a linked list in which\nthe trees appear in an increasing order of rank.first[P]\npoints to the tree with the smallest rank belonging toP.\nIfTis  a  tree  contained  in  a  priority  queueP,\nthenroot[T] is the root node ofT,next[T] is the tree","metadata":{"loc":{"lines":{"from":206,"to":226}}}}],["c0b4b7f1-61f8-4f11-be9d-a45afbb3537f",{"pageContent":"points to the tree with the smallest rank belonging toP.\nIfTis  a  tree  contained  in  a  priority  queueP,\nthenroot[T] is the root node ofT,next[T] is the tree\nfollowingTin the linked list ofP,andprev[T]isthe\ntree precedingTin the list. (Bothnext[T]andprev[T]\nmay be⊥.) Finally, ifTis a tree, thensufmin[T] points\nto the tree whose root has the smallestckeyamong all\nthe trees that followTin the linked list ofP.(Incaseof\nties, trees that appear earlier in the list are preferred.)\nA soft heap containing four binary trees of ranks\n0,1,4 and 5, respectively is shown in Figure 1. The num-\nbers within the nodes of the trees are theirckeyvalues.\nEach node has a listlist[x] of elements associated with\nit. (Lists of length 1 are not shown.)\n2.2  ThesiftoperationAs in Chazelle’s imple-\nmentation, the keystone of soft heaps operation is the\nsiftop\neration.  As we have mentioned, we would like\nthe num\nber of elements inlist[x]tobeaboutsize[x]. If","metadata":{"loc":{"lines":{"from":224,"to":243}}}}],["20bbb1d0-ed16-408b-9034-90f255910401",{"pageContent":"mentation, the keystone of soft heaps operation is the\nsiftop\neration.  As we have mentioned, we would like\nthe num\nber of elements inlist[x]tobeaboutsize[x]. If\nthe number of elements inlist[x] drops belowsize[x]/2,\nandxis not a leaf, we use asift(x) operation to add\nmore elements tolist[x].\nAsift(x) operation works as follows. By exchang-\ningleft[x]andright[x], if necessary, we make sure that\nleft[x] exists, and thatckey[left[x]]≤ckey[right[x]], if\nright[x]  exists.   (Recall  thatxis  not  a  leaf.)   Then,\nusing what Chazelle refers to as the “data structures’\nversion  of  car-pooling”,  we  take  all  the  elements  of\nlist[left[x]] and move them tolist[x]. (This can be done\nin constant time by concatenating the listslist[x]and\nlist[left[x]].)   We letckey[left[x]] be the newckey[x].\nThe\nlistlis  t[left[x\n]] is now empty. Ifleft[x] is a leaf, we\nsimply remove it from the tree by settingleft[x]to⊥.\nOtherwise, we recursively callsift(left[x]) to replenish\n478Copyright © by SIAM.","metadata":{"loc":{"lines":{"from":239,"to":261}}}}],["bab6ccb0-8a56-4346-baba-dd0488797c94",{"pageContent":"The\nlistlis  t[left[x\n]] is now empty. Ifleft[x] is a leaf, we\nsimply remove it from the tree by settingleft[x]to⊥.\nOtherwise, we recursively callsift(left[x]) to replenish\n478Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":256,"to":263}}}}],["7f309734-0d2f-4441-bff2-21abc8302988",{"pageContent":"Figure 1: A soft heap composed of four binary trees.\nlist[left[x]]. Finally, if the number of elements inlist[x]\nis still belowsize[x]andxstill not a leaf, we perform\nthese operations again. (See Figure 2.)\nIt is easy to check thatsiftoperations maintain\nheap order. We show below that ifxis not a leaf after\nasift(x) operation, thensize[x]≤|list[x]|≤3size[x].\n2.3  ThecombineoperationThe  second  most\nimportant operation in the implementation of soft heaps\nis thecombineoperation.  Acombine(x, y) operation\ntakes two root nodesxandyof the same rank, sayk,\nand combines the corresponding trees into a single tree\nof  rankk+ 1.    This  is  done  by  generating  a  new\nnodezand  settingleft[z]←x,right[z]←yand\nlist[z]←φ.Asift(z) operation is then performed\nto move enough elements intolist[z].  (See Figure 2.)\nThecombineop\neration isof\ncourse instrumental in the\nimplementation ofmeldandinsertoperations, as we\nexplain below.\nNote  that  we  do  not  do  any  rebalancing  of  the","metadata":{"loc":{"lines":{"from":265,"to":286}}}}],["b768e551-7dcb-4910-9493-121ed77610ad",{"pageContent":"Thecombineop\neration isof\ncourse instrumental in the\nimplementation ofmeldandinsertoperations, as we\nexplain below.\nNote  that  we  do  not  do  any  rebalancing  of  the\nbinary trees of the heaps.  The only structural changes\nperformed on the trees are: 1) Discarding a leaf (done by\nsift).  2) Combining two trees of rankkinto a larger\ntree of rankk+ 1 by allocating a new root (done by\ncombine).\n2.4  Theupdate-suffix-minoperationAn\nupdate-suffix-min(T)  operation  updates  thesufmin\npointers ofTand all the trees that precedeTin the\nlinked  list  of  trees.   Such  an  operation  is  performed\nwhenckey[x], wherex=root[T], is changed, e.g., by a\nsift(x) operation, whenTis a new tree added to the\nlist of trees, or when the tree followingTin the list is\ndeleted.\nAnupdate-suffix-min(T) operation traverses the\nlist  of  trees  backward  fromT.IfT\n\u0002\nis  a  tree  such\nthatsufmin[next[T\n\u0002\n]]  was  already  set  to  its  correct\nvalue, thensufmin[T\n\u0002\n]issettoT\n\u0002\n,ifckey[root[T\n\u0002\n]]≤","metadata":{"loc":{"lines":{"from":281,"to":313}}}}],["2be174f7-a540-43e2-9c12-a2ba470c10d9",{"pageContent":"list  of  trees  backward  fromT.IfT\n\u0002\nis  a  tree  such\nthatsufmin[next[T\n\u0002\n]]  was  already  set  to  its  correct\nvalue, thensufmin[T\n\u0002\n]issettoT\n\u0002\n,ifckey[root[T\n\u0002\n]]≤\nckey[root[next[T\n\u0002\n]]], or tosufmin[next[T\n\u0002\n]], otherwise.\n(See Figure 4 below.)\n2.5  Themake-heapoperationAmake-heap(e)\noperation receives an elementeand returns a priority\nqueuePcomposed of a single treeTcontaining a single\nnodexof rank 0. (See Figure 3.)\n2.6  ThemeldoperationAmeld(P, Q) operation\nreceives two priority queuesPandQand returns a new\npriority queue obtained by meldingPandQ.  Meld-\ningPandQis done in a fairly straightforward way. The\nlinked lists of trees ofPandQare combined, keeping a\nnon-decreasing order of rank.  Next, if two consecutive\ntreesT\n1\nandT\n2\nin the list have the same rank, they are\ncombined using acombine(root[T\n1\n], root[T\n2\n]) operation\nand the combined tree replaces them in the list. If three\nconsecutive treesT\n1\n,T\n2\nandT\n3\nin the list have the same\nrank, thenT\n1","metadata":{"loc":{"lines":{"from":301,"to":349}}}}],["84116c90-88e3-4615-a49b-cd49bd9978ac",{"pageContent":"combined using acombine(root[T\n1\n], root[T\n2\n]) operation\nand the combined tree replaces them in the list. If three\nconsecutive treesT\n1\n,T\n2\nandT\n3\nin the list have the same\nrank, thenT\n1\nis left alone, whileT\n2\nandT\n3\nare replaced\nby the combined treecombine(root[T\n2\n], root[T\n3\n]).  Fi-\n479Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":335,"to":362}}}}],["4ea78034-543b-4c8b-b35b-6879db9485d7",{"pageContent":"Functionsift(x)\nwhile|list[x]|<size[x]and(not\nleaf(x))do\nifleft[x]=⊥or(right[x]\b=⊥and\nckey[left[x]]>ckey[right[x]])then\nleft[x]↔right[x]\nconcatenate(list[x],list[left[x]])\nckey[x]←ckey[left[x]]\nlist[left[x]]←⊥\nifleaf(left[x])then\nleft[x]←⊥\nelse\nsift(left[x])\nFunctioncombine(x, y)\nz←new-node()\nleft[z]←x\nright[z]←y\nrank[z]←rank[x]+1\nifrank[z]≤rthen\nsize[z]←1\nelse\nsize[z]←(3∗size[x]+1)/2\nsift(z)\nreturnz\nFigure 2: Implementation ofsiftandcombine.\nnally, ifTis the last tree in the list affected by these\noperations, anupdate-suffix-min(T) is performed to\nupdate thesufminpointers. Ifk=rank[P]≤rank[Q],\nthen  it  is  easy  to  performmeld(P, Q)  operation  in\nO(k+ 1) time. (See Figure 3.)\n2.7  TheinsertoperationTo add an elemente\nto priority queueP,weusemake-heap(e) to generate a\npriority queue containing the single elementeand we\nthen meld this priority queue withP. (See Figure 3.)\n2.8  Theextract-minoperationAn\nextract-min(P) operation returns an element with a","metadata":{"loc":{"lines":{"from":364,"to":399}}}}],["4a67ef69-f577-459d-8943-0077b671a1e1",{"pageContent":"priority queue containing the single elementeand we\nthen meld this priority queue withP. (See Figure 3.)\n2.8  Theextract-minoperationAn\nextract-min(P) operation returns an element with a\nminimumcurrentkey contained inP.Ifeis contained\ninlist[x],  then the current key ofeisckey[x].   The\nimplementation ofextract-min(P) is extremely simple.\nLetT=sufmin[first[P]]\nand letx=root[\nT].   Thus\nxis  the  root  of  a  tree  ofPwith  the  smallestckey.\nWe  return  an  arbitrary  element  fromlist[x].    Note\nthatlist[x] is never empty.  If the number of elements\ninlist[x]  drops  belowsize[x]/2,  we  callsift(x)to\nreplenishxand thenupdate-suffix-min(T) to update\nthesufminpointers. (See Figure 3.)\n2.9  Pseudo-codeAs already mentioned, pseudo-\ncode  forsiftandcombineis  given  in  Figure  2,\nand  pseudo-code  formake-heap,meld,insertand\nextract-minis given in Figure 3.  (The reader is ad-\nvised to have at least a quick look at Figures 2 and 3,","metadata":{"loc":{"lines":{"from":396,"to":416}}}}],["6721a89a-81d6-4375-9d77-f2d21e2f2196",{"pageContent":"and  pseudo-code  formake-heap,meld,insertand\nextract-minis given in Figure 3.  (The reader is ad-\nvised to have at least a quick look at Figures 2 and 3,\nas they give a concise and precise definition of the main\nsoft heap operations.)\nThe fairly standard implementation of operations\nperformed  on  sequences  of  trees  are  given  in  Fig-\nure  4.Among  the  functions  described  there  are\nupdate-suffix-min, and the functionsmerge-intoand\nrepeated-combinecalled bymeld.   Finally,  Figure 5\ndescribes the functionsmake-treeandmake-node,\nthat\ngenerate anew\ntree and a new node, respectively, and\nthe functionleafthat checks whether a given node is\naleaf.\nInextract-min, we use a function calledpick-elem\nto pick, and delete, an arbitrary element fromlist[x],\nwhich is assumed to be a linked list.  Insift,weuse\na function calledconcatenateto concatenate the lists\nlist[x]andlist[left[x]].  The straightforward implemen-\ntation of these two functions is not given.\n3  Correctness","metadata":{"loc":{"lines":{"from":414,"to":436}}}}],["aa64cd6a-7512-42fc-81b0-e345c0015ba0",{"pageContent":"a function calledconcatenateto concatenate the lists\nlist[x]andlist[left[x]].  The straightforward implemen-\ntation of these two functions is not given.\n3  Correctness\nWe start by showing thatextract-minoperations do\nindeed return elements with minimum current keys:\nLemma 3.1.Aextract-min(P)always returns an ele-\nment ofPwith a minimalcurrentkey.\nProof.All  elements  inserted  intoPare  contained  in\nthe lists of nodes that are part of the trees formingP.\nAll operations performed on soft heaps maintain heap\norder.   Thus,  elements with the smallest current key\nin  a  tree  always  reside  at  the  root  of  that  tree.   A\nextract-min(P) operation uses thesufminpointer of\nthe first tree inPto access a tree whose rootxhas\na minimalckey,  and returns an elementecontained\ninlist[x], which is guaranteed to be non-empty.  This\nelement has a minimal key, as required.\u0002\nThe next two lemmas will be used to bound the\nnumber of corrupted elements.\n480Copyright © by SIAM.","metadata":{"loc":{"lines":{"from":433,"to":453}}}}],["8f5b44d0-eb3c-4496-ac19-2072d4a4cd24",{"pageContent":"inlist[x], which is guaranteed to be non-empty.  This\nelement has a minimal key, as required.\u0002\nThe next two lemmas will be used to bound the\nnumber of corrupted elements.\n480Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":449,"to":455}}}}],["b2d01052-49a5-4102-9554-8eca810d95f1",{"pageContent":"Functionmakeheap(e)\nP←new-heap()\nfirst[P]←make-tree(e)\nrank[P]←0\nreturnP\nFunctionmeld(P, Q)\nifrank[P]>rank[Q]thenP↔Q\nmerge-into(P, Q)\nrepeated-combine(Q, rank[P])\nreturnQ\nFunctioninsert(P, e)\nreturnmeld(P,make-heap(e))\nFunctionextract-min(P)\niffirst[P]=⊥then return⊥\nT←sufmin[first[P]]\nx←root[T]\ne←pick-elem(list[x])\nif|list[x]|≤size[x]/2then\nif notleaf(x)then\nsift(x)\nupdate-suffix-min(T)\nelse iflist[x]=φthen\nremove-tree(P, T)\nreturne\nFigure 3: Implementation of main soft heaps operations.\nLemma 3.2.Ifxisanodeofrankatmostr,  then\n|list[x]|=1.Ifxis  a  non-leaf  node  of  rankk≥r,\nthen\n1\n2\nsize[x]≤|list[x]|<3size[x].\nProof.Ifxis a node of rank at mostr, thensize[x]=1.\nIflist[x] becomes empty, thensift(x) brings exactly\none element intolist[x].\nSuppose now thatrank[x]≥r.If|list[x]|drops\nbelow\n1\n2\nsize[x], andxis not a leaf, thensift(x) adds\nelements  tolist[x]  until  either|list[x]|≥size[x],  or\nuntilxbecomes a leaf.   We next prove by induction","metadata":{"loc":{"lines":{"from":457,"to":497}}}}],["39a05ded-c22a-42bb-bea5-15b7e2e06b5f",{"pageContent":"below\n1\n2\nsize[x], andxis not a leaf, thensift(x) adds\nelements  tolist[x]  until  either|list[x]|≥size[x],  or\nuntilxbecomes a leaf.   We next prove by induction\nthat|list[x]|≤3size[x].  Ifrank[x]≤r, the claim is\nobvious.  We show now that if the claim holds for all\nvertices of rankk−1, then it also holds for all vertices\nof rankk.Letxbe a node of rankk. New elements are\nadded tolist[x] only when|list[x]|<size[x]. Asift(x)\noperation concatenateslist[y]tolist[x],  whereyis a\nchild ofx.Asyis of rankk−1, we get by induction\nthat|list[y]|<3siz\ne[y]≤3·\n2\n3\nsize[x]=2size[x]. Thus,\n|list[x]∪list[y]|<3size[x], as claimed.\u0002\nLemma 3.3.Ifnelements are inserted into soft heaps,\nthen the number of nodes of rankkis at mostn/2\nk\n.\nProof.By induction onk. A node of rank 0 is generated\nonly when a new element is inserted (using amake-heap\noperation)  into  a  soft  heap.    Thus,  the  number  of\nelements of rank 0 is at mostnas claimed. An element\nof rankkis generated only when two roots of rankk−1","metadata":{"loc":{"lines":{"from":492,"to":519}}}}],["0512f906-11c6-401c-9a61-1bc23b2d1709",{"pageContent":"operation)  into  a  soft  heap.    Thus,  the  number  of\nelements of rank 0 is at mostnas claimed. An element\nof rankkis generated only when two roots of rankk−1\nare combined.\u0002\nLemma 3.4.Ifnelements are inserted into soft heaps,\nthen the total number of corrupted elements contained\nin the heaps, at any given time, is at mostεn.\nProof.Each node of rank at mostrcontains a single\nelement.  Thus, all corrupted elements belong to nodes\nof rank greater thanr.  By Lemma 3.3, the number of\nnodes of rankkis at mostn/2\nk\n. By Lemma 3.2, a node\nof rankk>rcontains at most 3s\nk\n<6\n(\n3\n2\n)\nk−r\nelements.\nAsr=\u0003log\n2\n1\nε\n\u0004+ 5, the number of corrupted elements\nis at most\n∑\nk>r\nn\n2\nk\n·3s\nk\n<\nn\n2\nr\n·\n∑\nk>r\n6\n(\n1\n2\n)\nk−r\n(\n3\n2\n)\nk−r\n=\n6n\n2\nr\n·\n∑\ni≥1\n(\n3\n4\n)\ni\n=\n18n\n2\nr\n<εn.\n\u0002\n4  Amortized analysis\nWe  assign  potentials  to  heaps,  trees,  and  nodes.   A\nheap of rankkhas potentialk+ 1.  A tree whose root\nisxhas potential (r+2)·del(x), wheredel(x)isthe","metadata":{"loc":{"lines":{"from":517,"to":591}}}}],["ec36f6e4-1a23-491a-97d9-d8e5f914dca5",{"pageContent":"i\n=\n18n\n2\nr\n<εn.\n\u0002\n4  Amortized analysis\nWe  assign  potentials  to  heaps,  trees,  and  nodes.   A\nheap of rankkhas potentialk+ 1.  A tree whose root\nisxhas potential (r+2)·del(x), wheredel(x)isthe\nnumber of elements deleted fromxsince the lastsift(x)\noperation, or since the creation ofx.Ifxisarootnode\nof rankk, thenxhas potentialk+7. Ifxis a non-root\nnode, it has potential 1.\nWe start with the analysis ofsift. Suppose thatx\nis a node of rankk, thatyis a child ofx, and that the\nelements oflist[y]aremovedtolist[x].  If|list[y]|<\n481Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":581,"to":601}}}}],["1c5cf26c-331b-438d-b9ad-8e7f5c1b1dfe",{"pageContent":"Functionmerge-into(P, Q)\nifrank[P]>rank[Q]thenabort\nT\n1\n←first[P]\nT\n2\n←first[Q]\nwhileT\n1\n\b=⊥do\nwhilerank[T\n1\n]>rank[T\n2\n]do\nT\n2\n←next[T\n2\n]\nT\n\u0002\n1\n←next[T\n1\n]\ninsert-tree(Q, T\n1\n,T\n2\n)\nT\n1\n←T\n\u0002\n1\nFunctionrepeated-combine(Q, k)\nT←first[Q]\nwhilenext[T]\b=⊥do\nifrank[T]=rank[next[T]]then\nifnext[next[T]] =⊥or\nrank[T]\b=rank[next[next[T]]]\nthen\nroot[T]←\ncombine(root[T], root[next[T]])\nrank[T]←rank[root[T]]\nremove-tree(Q, next[T])\nelse ifrank[T]>kthen\nbreak\nT←next[T]\nifrank[T]>rank[Q]then\nrank[Q]←rank[T]\nupdate-suffix-min(T)\nFunctionupdate-suffix-min(T)\nwhileT\b=⊥do\nifckey[root[T]]≤\nckey[root[sufmin[next[T]]]]then\nsufmin[T]←T\nelse\nsufmin[T]←sufmin[next[T]]\nT←prev[T]\nFunctioninsert-tree(P, T\n1\n,T\n2\n)\nnext[T\n1\n]←T\n2\nifprev[T\n2\n]=⊥then\nfirst[P]←T\n1\nelse\nnext[prev[T\n2\n]]←T\n1\nFunctionremove-tree(P, T)\nifprev[T]=⊥then\nfirst[P]=next[T]\nelse\nnext[prev[T]]←next[T]\nifnext[T]\b=⊥then\nprev[next[T]]←prev[T]\nFigure 4: Implementation ofupdate-suffix-minand other operations on sequences of trees\n1\n2","metadata":{"loc":{"lines":{"from":603,"to":693}}}}],["21f7ad2b-c180-4369-ba83-103363f68068",{"pageContent":"ifprev[T]=⊥then\nfirst[P]=next[T]\nelse\nnext[prev[T]]←next[T]\nifnext[T]\b=⊥then\nprev[next[T]]←prev[T]\nFigure 4: Implementation ofupdate-suffix-minand other operations on sequences of trees\n1\n2\nsize[y], thenyis a leaf, andydisappears as a result\nof this operation.  The unit potential released by the\ndisappearance ofypays for this operation.  If, on the\nother hand,|list[y]|≥\n1\n2\nsize[y], and hence|list[y]|≥\n\u0003\nsize[y]\n2\n\u0004, we split the unit cost of the operation among\nthe|list[y]|elements  participating  in  the  ‘car-pool’.\nThe charge for each element is at most\u0003\nsize[y]\n2\n\u0004\n−1\n=\n\u0003\ns\nk−1\n2\n\u0004\n−1\n.  An element is charged at most once at each\nrank, thus its total ‘travel expenses’ are\n∑\nk≥0\n⌈\ns\nk\n2\n⌉\n−1\n≤r+2\n∑\ni≥0\n(\n2\n3\n)\ni\n=r+6 =O(log\n1\nε\n).\nWe next consider acombine(x, y) operation which\ncombines two trees of rankk, rooted atxandy,into\natreeofrankk+ 1,  rooted at a new nodez.The\npotentials of bothxandydecrease fromk+ 7 to 1,\nreleasing  2k+ 12  units  of  potential.    One  of  these","metadata":{"loc":{"lines":{"from":685,"to":744}}}}],["95dd2677-252d-4454-81bc-935994faa531",{"pageContent":"combines two trees of rankk, rooted atxandy,into\natreeofrankk+ 1,  rooted at a new nodez.The\npotentials of bothxandydecrease fromk+ 7 to 1,\nreleasing  2k+ 12  units  of  potential.    One  of  these\nunits pays for the constant cost of the operation,k+8\nunits  are  assigned  toz,  one  unit  is  used  to  increase\nthe potential of the heap containing the newly formed\ntree, if it is now the tree with the largest rank.  The\nremainingk+ 2 units are used, if needed, to pay for\nan ensuingupdate-suffix-minoperation.  (Note that\n1+(k+8)+1+(k+2)=2k+ 12.)\nAmeld(P, Q)  operation  receives  two  heaps,  of\nrankskandk\n\u0002\nrespectively.  Suppose thatk≤k\n\u0002\n.The\nmeld operation first merges the lists of trees ofPandQ,\neffectively destroyingP. This takesO(k+1) time, which\nis paid by the released potential ofP.  The subsequent\ncombineoperations pay for themselves and for the en-\n482Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.","metadata":{"loc":{"lines":{"from":741,"to":763}}}}],["fb3d55d9-d4e8-4958-a555-b5e780c23b43",{"pageContent":"is paid by the released potential ofP.  The subsequent\ncombineoperations pay for themselves and for the en-\n482Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":760,"to":764}}}}],["a98dccc0-0099-48e6-858f-deb85b61b5c2",{"pageContent":"Functionmaketree(e)\nT←new-tree()\nroot[T]←make-node(e)\nnext[T]←⊥\nprev[T]←⊥\nrank[T]←0\nsufmin[T]←T\nreturnT\nFunctionmakenode(e)\nx←new-node()\nlist[x]←{e}\nckey[x]←key[e]\nrank[x]←0\nsize[x]←1\nleft[x]←⊥\nright[x]←⊥\nreturnx\nFunctionleaf(x)\nreturn(left[x]=⊥)and\n(right[x]=⊥)\nFigure 5: Implementation ofmake-tree,make-nodeandleaf.\nsuingupdate-suffix-minoperation. If nocombineop-\nerations are performed,  the potential released by the\ndestruction ofPpays for theupdate-suffix-minoper-\nation.\nFinally,    we   bound   the   amortized   cost   of\nextract-min(P)   operations.Anextract-min(P)\noperation locates an elementewith minimal current\nkey in constant time.  Suppose thatxis the root node\ncontaininge.   If after deletingefromlist[x] we still\nhave|list[x]|≥\n1\n2\nsize[x], or if|list[x]|>0andxis a\nleaf, then no further action is taken.  Note, however,\nthatdel(x), the number of elements deleted fromlist[x]\nsince  the  lastsift(x)  operation,  is  increased  by  1,","metadata":{"loc":{"lines":{"from":766,"to":802}}}}],["7d289d14-b039-458b-9a0f-6a438bb71ef4",{"pageContent":"leaf, then no further action is taken.  Note, however,\nthatdel(x), the number of elements deleted fromlist[x]\nsince  the  lastsift(x)  operation,  is  increased  by  1,\nand the potential of tree whose root isxis increased\nbyr+ 2.   This total cost of 1 + (r+2) =r+3 is\ncharged toe, which would never be charged again.  If\n|list[x]|<\n1\n2\nsize[x]andxis not a leaf, then asift(x)\noperation is performed. Asxis not a leaf, it must have\nhad at leastsize[x] elements in its list after the previous\nsift(x) operation.   Thusdel(x)≥\u0003\nsize[x]\n2\n\u0004,  and the\npotential of the tree, prior to thesiftoperation, is at\nleast (r+2)\u0003\nsize[x]\n2\n\u0004=(r+2)\u0003\ns\nk\n2\n\u0004, wherek=rank[x].\nIt is not difficult to verify that for everyk≥0wehave\n(r+2)\n⌈\ns\nk\n2\n⌉\n≥k+1.\nIndeed, for 0≤k≤r+1, we have (r+2)\u0003\ns\nk\n2\n\u0004=r+2≥\nk+1.  Fork=r+2, we haves\nr+2\n=3andthus\n(r+2)\u0003\ns\nr+2\n2\n\u0004=2(r+2)>r+3. Fork≥r+3, we have\n(r+2)\u0003\ns\nk\n2\n\u0004≥\nr+2\n2\n(\n3\n2\n)\nk−r\n≥k+1, as\n1\n2\n(\n3\n2\n)\nk−r\n≥\nk+1\nr+2\n,\nfork≥r+ 3. This decrease of at leastk+ 1 in potential","metadata":{"loc":{"lines":{"from":800,"to":870}}}}],["79dcb6e7-87e6-4a21-86e1-3daa45e46a01",{"pageContent":"r+2\n=3andthus\n(r+2)\u0003\ns\nr+2\n2\n\u0004=2(r+2)>r+3. Fork≥r+3, we have\n(r+2)\u0003\ns\nk\n2\n\u0004≥\nr+2\n2\n(\n3\n2\n)\nk−r\n≥k+1, as\n1\n2\n(\n3\n2\n)\nk−r\n≥\nk+1\nr+2\n,\nfork≥r+ 3. This decrease of at leastk+ 1 in potential\nof the tree pays for theupdate-suffix-minoperation\nthat follows thesift(x) operation.  Finally, if the root\nnodexis a leaf,  andeis the last element inlist[x],\nthenxand the tree rooted atxare removed. Thek+7\nunits of potential ofxare more than enough to pay for\ntheupdate-suffix-minoperation performed after the\nremoval ofx.\nWhen an elementeis inserted into a soft heap, a\nnew heap, a new tree and a new node are created. The\nheap, of rank 0, is assigned one potential unit, the tree\nzero units, while the new node, of rank 0, is assigned 7\nunits. During its life time, at mostr+ 6 potential units\nare  charged  toeto  pay  for  its  movements.   Finally,\nadditionalr+3 units are charged toewhen it is deleted.\nIf  we  change  the  1  unit  of  actual  work  involved  in","metadata":{"loc":{"lines":{"from":839,"to":885}}}}],["1575e527-bd9f-48f6-857d-c0d7b20d0d45",{"pageContent":"are  charged  toeto  pay  for  its  movements.   Finally,\nadditionalr+3 units are charged toewhen it is deleted.\nIf  we  change  the  1  unit  of  actual  work  involved  in\ninsertingeinto a soft heap of its own, and the 8 potential\nunits assigned to this heap toe, we get that the total\ncharge fore, from its insertion until its deletion, is at\nmost 8 + (r+6)+(r+3) = 2r+17 =O(log\n1\nε\n).  We\nhave thus proved:\nTheorem 4.1.The amortized cost of inserting an ele-\nment into a soft heap with error rateεisO(log\n1\nε\n).The\namortized cost of all other operations is0.\n5  Adding adeleteoperation\nWe next consider the implementation ofdeleteopera-\ntions. One option, used by Chazelle [4], is to implement\ndeleteoperations in alazymanner.  Deleted elements\nare simply marked as deleted. If anextract-minoper-\nation returns an element marked as deleted, the opera-\ntion is simply called again until a non-deleted element\nis returned. The drawback of such an implementation is","metadata":{"loc":{"lines":{"from":883,"to":907}}}}],["29cbc579-e97e-4702-9f15-b315e9993ed5",{"pageContent":"ation returns an element marked as deleted, the opera-\ntion is simply called again until a non-deleted element\nis returned. The drawback of such an implementation is\nthat it is not space optimal, as the space used by deleted\nelements cannot be reclaimed immediately. (This can be\nfixed by rebuilding the data structure when more than\nhalf of the elements are deleted.)\nWe  implementdelete(e)  operations  directly  as\nfollows. We deleteefrom the linked listlist[x] currently\ncontaining it. This can be easily done in constant time,\nusing the forward and backward pointers ofein the list,\nwithout knowing the indentity ofx. (The nodexcan be\nretrieved using a union-find data structure, but this is\ntoo expensive in our context.) We do assume, however,\nthat the first element in a linked list knows to which list\nit belongs to.  Thus, ifeis the last remaining element\noflist[x], we can initiate asift(x) operation to bring\n483Copyright © by SIAM.","metadata":{"loc":{"lines":{"from":905,"to":922}}}}],["b4fb17a5-cbf4-4df3-8169-60743ae9094c",{"pageContent":"that the first element in a linked list knows to which list\nit belongs to.  Thus, ifeis the last remaining element\noflist[x], we can initiate asift(x) operation to bring\n483Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":919,"to":924}}}}],["818d7662-d8dd-4c93-9a5e-d3969f3821f2",{"pageContent":"new elements intolist[x].  Ifxis a leaf, it is removed\nfrom the data structure. (To implement this we need a\npointer to the parent ofxin the tree.)\nFor  each  no dexwe keep a numbernum[x] that\ngives the number of elements inlist[x], includingghost\nelements  that  were  deleted  fromlist[x]  or  from  lists\nthat  were  appended  tolist[x].    We  may  thus  have\n|list[x]|<num[x].   Whenlist[left[x]] is appended to\nlist[x],  we donum[x]←num[x]+num[left[x]].   We\ndo not decrementnum[x] when an element is deleted\nfromlist[x], as we do not know when it happens.  (In\nfact,num[x] values should also be maintained by the\nimplementation of Section 2. All occurrences of|list[x]|\nin  the  pseudo-code  given  in  Figures  2  and  3  should\nby replaced bynum[x], andnum[x] values should be\nupdated when lists are created and moved.)\nA  moment’s  reflection  shows  that  the  amortized\nanalysis\nof  Section4\nremains  valid.Some  of  the\noperations are charged to ghost elements, i.e., elements","metadata":{"loc":{"lines":{"from":926,"to":946}}}}],["9fa89576-4586-4f5c-bded-f05fe2ad430f",{"pageContent":"A  moment’s  reflection  shows  that  the  amortized\nanalysis\nof  Section4\nremains  valid.Some  of  the\noperations are charged to ghost elements, i.e., elements\nthat were already deleted, but this is legal.\n6  Comparison with Chazelle’s implementation\nThe main difference between our implementation and\nChazelle’s [4] implementation is that our implementa-\ntion usesbinarytrees, whereas Chazelle’s implementa-\ntion usesbinomialtrees.  We believe that our imple-\nmentation is simpler and more intuitive, as we argue\nbelow.\nChazelle’s binomial trees arebinarized. Each bino-\nmial tree is represented as a binary tree, with each node\nof the binomial tree corresponding to aleft pathin the\nbinary tree.  Thus, only root nodes or nodes that are\nright children of their parents have elements and keys\nassociated with them.   In our binary trees,  all nodes\nplay the same role.\nThe trees in Chazelle’s implementation are actually\npartialbinomial trees, as tree nodes that remain with-","metadata":{"loc":{"lines":{"from":942,"to":963}}}}],["17cb0134-0ca1-45f5-907d-d70bd6c752af",{"pageContent":"associated with them.   In our binary trees,  all nodes\nplay the same role.\nThe trees in Chazelle’s implementation are actually\npartialbinomial trees, as tree nodes that remain with-\nout elements are deleted.  In a standard binomial tree,\nanodeofrankkhas exactlykchildren.  In Chazelle’s\npartial binomial trees, a node of rankkmay have less\nthankchildren. If the number of children of an empty\nroot node of rankkdrops belowk/2, Chazelle resorts to\naclean-upoperation that breaks the tree into a collec-\ntion of trees. This slightly complicates the implementa-\ntion and makes the analysis somewhat subtler. No such\ncomplications arise in our implementation.\nAnother important difference between our imple-\nmentation and Chazelle’s implementation is that we ex-\nplicitly control the number of elements contained in the\nlist of a node of rankk. We believe that this makes our\nimplementation more intuitive and the analysis more\ntransparent.\nThe  way  we  implement  delete  operations  is  also","metadata":{"loc":{"lines":{"from":960,"to":979}}}}],["e49fe440-6ddc-4ce4-84b0-04da1eac4b9d",{"pageContent":"list of a node of rankk. We believe that this makes our\nimplementation more intuitive and the analysis more\ntransparent.\nThe  way  we  implement  delete  operations  is  also\ndifferent  from  the  way  suggested  by  Chazelle.   Our\nimplementation is automatically space efficient, without\nthe need for periodic rebuildings.\nThe changes in the implementations enable us to\npresent a simplified and unified amortized analysis.\n7  Concluding remarks\nWe presented a simpler implementation of Chazelle’s\nsoft heaps.  It would be interesting to find additional\napplications of this data structure.   It would also be\ninteresting to know whether the soft heap operations\ncould be implemented inO(log\n1\nε\n)worst-casetime.\nIn  the  implementation  presented,  the  amortized\nnumber ofcomparisonsmade for each element inserted\ninto soft heaps is 2 log\n1\nε\n+O(1). It is possible to reduce\nthis number to (1 +o(1)) log\n1\nε\nby maintainingsufmin\npointers only for trees of rank greater than, say, 2rand","metadata":{"loc":{"lines":{"from":976,"to":1004}}}}],["4e7b0cb8-c7b0-4def-9152-826f37325968",{"pageContent":"into soft heaps is 2 log\n1\nε\n+O(1). It is possible to reduce\nthis number to (1 +o(1)) log\n1\nε\nby maintainingsufmin\npointers only for trees of rank greater than, say, 2rand\nkeeping theckeyvalues of the roots of trees of rank at\nmost 2rin a small priority queue.\nIt is interesting to point out that if we setr=∞\nin  our  construction,  i.e.,  havesize[x]  =  1  for  every\nnodex, we get a standard meldable priority queue data\nstructure in which no corruptions occur. Each operation\nis performed inO(logn) amortized time, wherenis the\ntotal number of elements inserted into priority queues.\nThis may be viewed as an alternative to the celebrated\nBinomial  heapsdata structure of Vuillemin [11] (See\nalso [5]).\nAs noted by Chazelle [4, 2], soft heaps give rise to a\nnew linear-time median selection algorithm, very differ-\nent from the algorithms of Blumet al.[1], Sch ̈onhageet\nal.[10], and Dor and Zwick [6]. It would be interesting\nto explore the possibility of using soft heaps to obtain","metadata":{"loc":{"lines":{"from":996,"to":1020}}}}],["88988208-fce9-4864-9ba5-b5d977afd42e",{"pageContent":"ent from the algorithms of Blumet al.[1], Sch ̈onhageet\nal.[10], and Dor and Zwick [6]. It would be interesting\nto explore the possibility of using soft heaps to obtain\nan algorithm that finds the median ofnelements using\nless than 2.95ncomparisons.  The best lower bound on\nthe number of comparisons needed to find the median\nis currently (2 +ε)n, for a fixed, but tiny,ε>0(see\nDor and Zwick [7]).\nAcknowledgment\nWe would like to thank Bob Tarjan for his comments\non an earlier version of this paper.\nReferences\n[1] M. Blum, R.W. Floyd, V. Pratt, R.L. Rivest, and\nR.E. Tarjan.  Time bounds for selection.Journal  of\nComputer and System Sciences, 7(4):448–461, 1973.\n[2] B. Chazelle.The  Discrepancy  Method:  Randomness\nand  Complexity.  Cambridge University Press, 2000.\nAvailable on-line at:http://www.cs.princeton.edu/\n~chazelle/pubs/book.pdf.\n484Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.","metadata":{"loc":{"lines":{"from":1018,"to":1038}}}}],["e5ff1484-18e5-4a45-beb2-2d2ccb183660",{"pageContent":"Available on-line at:http://www.cs.princeton.edu/\n~chazelle/pubs/book.pdf.\n484Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":1035,"to":1039}}}}],["b9b12903-29dc-4861-8225-c4e7c0fd6e73",{"pageContent":"[3] B. Chazelle. A minimum spanning tree algorithm with\ninverse-Ackermann type complexity.Journal  of  the\nACM, 47(6):1028–1047, 2000.\n[4] B. Chazelle. The soft heap: an approximate priority\nqueue with optimal error rate.Journal of the ACM,\n47(6):1012–1027, 2000.\n[5] T.H.  Cormen,  C.E.  Leiserson,  R.L.  Rivest,  and\nC. Stein.Introduction to algorithms. The MIT Press,\n2nd edition, 2001.\n[6] D. Dor and U. Zwick.  Selecting the median.SIAM\nJournal on Computing, 28:1722–1758, 1999.\n[7] D. Dor and U. Zwick. Median selection requires (2+\u0002)n\ncomparisons.SIAM Journal on Discrete Mathematics,\n14:312–325, 2001.\n[8] S. Pettie and V. Ramachandran.  An optimal mini-\nmum spanning tree algorithm.Journal of the ACM,\n49(1):16–34, 2002.\n[9] S. Pettie and V. Ramachandran.  Randomized min-\nimum spanning tree algorithms using exponentially\nfewer random bits.ACM Transactions on Algorithms,\n4(1):1–27, 2008.\n[10] A. Sch ̈onhage, M. Paterson, and N. Pippenger. Find-","metadata":{"loc":{"lines":{"from":1041,"to":1062}}}}],["b22c4c1d-4efa-4aef-a88b-d0c45c8816c1",{"pageContent":"imum spanning tree algorithms using exponentially\nfewer random bits.ACM Transactions on Algorithms,\n4(1):1–27, 2008.\n[10] A. Sch ̈onhage, M. Paterson, and N. Pippenger. Find-\ning the median.Journal of Computer and System Sci-\nences, 13(2):184–199, 1976.\n[11] J. Vuillemin. A data structure for manipulating prior-\nity queues.Communications of the ACM, 21:309–314,\n1978.\n485Copyright © by SIAM. \nUnauthorized reproduction of this article is prohibited.\nDownloaded 04/18/25 to 117.238.115.22 . Redistribution subject to SIAM license or copyright; see https://epubs.siam.org/terms-privacy","metadata":{"loc":{"lines":{"from":1059,"to":1070}}}}]],{"0":"6acb3552-fa2c-4953-b86e-37a179e599b6","1":"c5226c24-b1a9-4023-9539-3c0cc4a8bdeb","2":"889e34be-8185-492e-9cdb-2c1800fb0b13","3":"f656c376-652c-4d45-8b15-659d414ebece","4":"384ae81c-52a2-4883-a557-f8862710868a","5":"7c910f57-f394-4b55-880a-bd9fbc056ffc","6":"0200ee4f-50f6-4e0e-9dfa-ea75e638047a","7":"2c49ca1e-9f9e-481a-b899-70edc20b1aed","8":"134d918f-fab9-48dc-ade3-99097c9330aa","9":"5ce56098-91a7-46dc-abcf-9d4c49cb2cbb","10":"c0b4b7f1-61f8-4f11-be9d-a45afbb3537f","11":"20bbb1d0-ed16-408b-9034-90f255910401","12":"bab6ccb0-8a56-4346-baba-dd0488797c94","13":"7f309734-0d2f-4441-bff2-21abc8302988","14":"b768e551-7dcb-4910-9493-121ed77610ad","15":"2be174f7-a540-43e2-9c12-a2ba470c10d9","16":"84116c90-88e3-4615-a49b-cd49bd9978ac","17":"4ea78034-543b-4c8b-b35b-6879db9485d7","18":"4a67ef69-f577-459d-8943-0077b671a1e1","19":"6721a89a-81d6-4375-9d77-f2d21e2f2196","20":"aa64cd6a-7512-42fc-81b0-e345c0015ba0","21":"8f5b44d0-eb3c-4496-ac19-2072d4a4cd24","22":"b2d01052-49a5-4102-9554-8eca810d95f1","23":"39a05ded-c22a-42bb-bea5-15b7e2e06b5f","24":"0512f906-11c6-401c-9a61-1bc23b2d1709","25":"ec36f6e4-1a23-491a-97d9-d8e5f914dca5","26":"1c5cf26c-331b-438d-b9ad-8e7f5c1b1dfe","27":"21f7ad2b-c180-4369-ba83-103363f68068","28":"95dd2677-252d-4454-81bc-935994faa531","29":"fb3d55d9-d4e8-4958-a555-b5e780c23b43","30":"a98dccc0-0099-48e6-858f-deb85b61b5c2","31":"7d289d14-b039-458b-9a0f-6a438bb71ef4","32":"79dcb6e7-87e6-4a21-86e1-3daa45e46a01","33":"1575e527-bd9f-48f6-857d-c0d7b20d0d45","34":"29cbc579-e97e-4702-9f15-b315e9993ed5","35":"b4fb17a5-cbf4-4df3-8169-60743ae9094c","36":"818d7662-d8dd-4c93-9a5e-d3969f3821f2","37":"9fa89576-4586-4f5c-bded-f05fe2ad430f","38":"17cb0134-0ca1-45f5-907d-d70bd6c752af","39":"e49fe440-6ddc-4ce4-84b0-04da1eac4b9d","40":"4e7b0cb8-c7b0-4def-9152-826f37325968","41":"88988208-fce9-4864-9ba5-b5d977afd42e","42":"e5ff1484-18e5-4a45-beb2-2d2ccb183660","43":"b9b12903-29dc-4861-8225-c4e7c0fd6e73","44":"b22c4c1d-4efa-4aef-a88b-d0c45c8816c1"}]